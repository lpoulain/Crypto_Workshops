# Lab 3: cracking the integrity of AES-CBC mode

Some improvements were made to the encryption scheme used in lab 1. This time, the complete plaintext is encrypted using AES-CBC for confidentiality. SHA256 is used for integrity.

In order to compromise the integrity of this lab, it is important to understand how does AES-CBC work (if you do, you can skip the next section)


### What is AES-CBC ?

AES-CBC is a combination of two algorithms to encrypt variable-length messages.

AES is a popular pseudo-random function which is encrypting 128-bit (16 bytes) blocks using a 128-bit, 192-bit or 256-bit private key. It is called as such as the output is virtually indistinguishable from random data.

A 128-bit key may seem quite small when the typical public key these days is 2048-bit. But with symmetric encyrption, all the keys of the 128-bit space can be used. That is 2<sup>128</sup> possibilities - more than any supercomputer can handle. By contrast, a 2048-bit public key generated by the RSA algorithm is a product of two 1024-bit prime numbers - not all possibilities in the 2048-bit space cannot be used, which explains why asymmetric encryption is using much larger keys than symmetric encryption

The CBC mode is the way AES is used and combined to encrypt a message which is much larger than 16 bytes. Indeed, splitting the message into 16-bytes blocks and encrypting each message individually (also called the Electronic Codebook or ECB mode) would be insecure. There is no randomness, so two same plaintext blocks would be encrypted the exact same way (see the [pictures](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29) on Wikipedia)

Although not the safest mode, the CBC mode is still popular and still often used in some HTTPS connections (also, at the time of this writing, it is not implemented by the PyCrypto library)

CBC is working as is:

- The plaintext is split in 16-bytes plaintext blocks pb<sub>1</sub>, pb<sub>2</sub>, ...,  pb<sub>n</sub>. They will eventually be encrypted in cipherblocks cb<sub>1</sub>, cb<sub>2</sub>, ...,  cb<sub>n</sub>
- The last block is padded to make 16 bytes
- You come up with a randomly generated 16-bytes initialization vector (IV) which will be considered the first cipher block cb<sub>0</sub>
- Each cipherblock is computed as is: cb<sub>n</sub> = AES(pb<sub>n</sub> XOR cb<sub>n-1</sub>)
- The final ciphertext will be cb<sub>0</sub>, cb<sub>1</sub>, cb<sub>2</sub>, ...,  cb<sub>n</sub>

See [Wikipedia](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29) for further details.

### The lab

Like for Lab 1, the goal is to remove the "None" access for user "alice" when running the Oracle. The other permissions for alice should remain intact.

**How to compromise the integrity**

In this case you are aware of the plaintext format, as displayed on the left when running the Oracle (note for Windows users: each carriage return is stored as one byte only). It is however performing some structural checks.

If AES-CBC is pretty secure in terms of confidentiality, it is subject to modification. Consider the following plaintext, split into 16-bytes blocks:

                                [............] (the IV)
    [This is a sample]          [............]
    [ plaintext to sh]          [............]
    [ow how modifying]    =>    [............]
    [the ciphertext w]          [............]
    [orks.           ]          [............]

But what if we modified one byte of the ciphertext (noted as 'A' below)? The decompression would give:

    [............]
    [............]          [This is a sample]
    [............]          [ plaintext to sh]
    [.....A......]    =>    [????????????????]
    [............]          [the c?phertext w]
    [............]          [orks.           ]

Any cipherblock slightly modified is likely to be decrypted as binary garbage. But because the modified cipherblock is XOR'ed to the next decrypted block during decryption, just flipping one bit would flip the same relative bit in the next plaintext block ("c?phertext" in the above example)

Can you find a way to modify the ciphertext while keeping enough integrity so the Oracle doesn't find any error?

**How to get around the integrity control?**

The Oracle is using SHA256 to prevent any tampering with the ciphertext.

How to get around that? Check the [PyCrypto documentation](https://www.dlitz.net/software/pycrypto/api/current/) and take a good look at how SHA256 works.

To help you determine where is the SHA256 signature stored, there are two versions of the ciphertext. Comparing the two in hex (on Mac or Linux, use the command hexdump) should help.
